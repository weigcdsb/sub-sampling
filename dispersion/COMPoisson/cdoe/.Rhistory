}
plot(r, mVC.mse.beta, type = 'l', ylim = c(0, 1))
plot(r, mVC.mse.gam, type = 'l', ylim = c(0, 1))
plot(r, mVC.mse, type = 'l', ylim = c(0, 1))
.rs.restartR()
setwd("C:\\Users\\gaw19004\\Documents\\GitHub\\sub-sampling\\COM-Poisson\\cdoe")
install.packages("COMPoissonReg_0.7.0.tar.gz", repos = NULL, type="source")
load("D:/GitHub/sub-sampling/COM-Poisson/cdoe/comResults.RData")
rbind(proc.poi, proc.cmp.nuOff, proc.cmp.nuOn)[, 1:3]
mean((y - fitted1)^2)
mean((y - fitted2)^2)
mean((y - fitted3)^2)
mean((y - qpois(0.5, fit1$fitted.values))^2)
mean((y - predict.cmp.quantile(0.5, fit2, cbind(1, x)))^2)
mean((y - predict.cmp.quantile(0.5, fit3, cbind(1, x)))^2)
predict.cmp.quantile <- function(q, fit, X){
lam <- exp(X %*% coef(fit)[1:ncol(fit$X)])
nu <- nu(fit)
out <- rep(NA, nrow(X))
for(i in 1:nrow(X)){
out[i] <- qcmp(q, lam[i], nu[i])
}
return(out)
}
plot(y, col = 1, pch = 1, main = 'median')
lines(qpois(rep(0.5, n), fit1$fitted.values),
type = 'p', col = 2, pch = 2)
lines(predict.cmp.quantile(0.5, fit2, cbind(1, x)),
type = 'p', col = 3, pch = 3)
lines(predict.cmp.quantile(0.5, fit3, cbind(1, x)),
type = 'p', col = 4, pch = 4)
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
mean((y - qpois(0.5, fit1$fitted.values))^2)
mean((y - predict.cmp.quantile(0.5, fit2, cbind(1, x)))^2)
mean((y - predict.cmp.quantile(0.5, fit3, cbind(1, x)))^2)
library(COMPoissonReg)
mean((y - qpois(0.5, fit1$fitted.values))^2)
mean((y - predict.cmp.quantile(0.5, fit2, cbind(1, x)))^2)
mean((y - predict.cmp.quantile(0.5, fit3, cbind(1, x)))^2)
plot(r, unif.mse.gam, type = 'b', ylim = c(0, 0.07),
col = 1, pch = "1", lwd = 2,
main = 'gam', ylab = 'MSE')
lines(r, mMSE.mse.gam, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.gam, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.gam, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
plot(r, unif.mse.gam, type = 'b', ylim = c(0, 0.07),
col = 1, pch = "1", lwd = 2,
main = 'gam', ylab = 'MSE')
lines(r, mMSE.mse.gam, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.gam, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.gam, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\mean.png',
width = 600,height = 600, res = 100)
plot(y, col = 1, pch = 1, main = 'mean')
lines(fitted1, col = 2, pch = 2, type = 'p')
lines(fitted2, col = 3, pch = 3, type = 'p')
lines(fitted3, col = 4, pch = 4, type = 'p')
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
dev.off()
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\median.png',
width = 600,height = 600, res = 100)
plot(y, col = 1, pch = 1, main = 'median')
lines(qpois(rep(0.5, n), fit1$fitted.values),
type = 'p', col = 2, pch = 2)
lines(predict.cmp.quantile(0.5, fit2, cbind(1, x)),
type = 'p', col = 3, pch = 3)
lines(predict.cmp.quantile(0.5, fit3, cbind(1, x)),
type = 'p', col = 4, pch = 4)
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
dev.off()
mean((y - fitted1)^2)
mean((y - fitted2)^2)
mean((y - fitted3)^2)
rbind(proc.poi, proc.cmp.nuOff, proc.cmp.nuOn)[, 1:3]
rbind(proc.poi, proc.cmp.nuOff, proc.cmp.nuOn)[, 1:3]
plot(nu)
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\theta.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse, type = 'b', ylim = c(0, 0.35),
col = 1, pch = "1", lwd = 2,
main = 'theta', ylab = 'MSE')
lines(r, mMSE.mse, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
plot(r, unif.mse.gam, type = 'b', ylim = c(0, 0.07),
col = 1, pch = "1", lwd = 2,
main = 'gam', ylab = 'MSE')
lines(r, mMSE.mse.gam, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.gam, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.gam, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\theta.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse, type = 'b', ylim = c(0, 0.35),
col = 1, pch = "1", lwd = 2,
main = 'theta', ylab = 'MSE')
lines(r, mMSE.mse, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\beta.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse.beta, type = 'b', ylim = c(0, 0.3),
col = 1, pch = "1", lwd = 2,
main = 'beta', ylab = 'MSE')
lines(r, mMSE.mse.beta, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.beta, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.beta, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\gamma.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse.gam, type = 'b', ylim = c(0, 0.07),
col = 1, pch = "1", lwd = 2,
main = 'gamma', ylab = 'MSE')
lines(r, mMSE.mse.gam, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.gam, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.gam, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
load("D:/GitHub/sub-sampling/COM-Poisson/cdoe/comResults2.RData")
rbind(proc.poi, proc.cmp.nuOff, proc.cmp.nuOn)[, 1:3]
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\mean.png',
width = 600,height = 600, res = 100)
plot(y, col = 1, pch = 1, main = 'mean')
lines(fitted1, col = 2, pch = 2, type = 'p')
lines(fitted2, col = 3, pch = 3, type = 'p')
lines(fitted3, col = 4, pch = 4, type = 'p')
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
dev.off()
mean((y - fitted1)^2)
mean((y - fitted2)^2)
mean((y - fitted3)^2)
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\median.png',
width = 600,height = 600, res = 100)
plot(y, col = 1, pch = 1, main = 'median')
lines(qpois(rep(0.5, n), fit1$fitted.values),
type = 'p', col = 2, pch = 2)
lines(predict.cmp.quantile(0.5, fit2, cbind(1, x)),
type = 'p', col = 3, pch = 3)
lines(predict.cmp.quantile(0.5, fit3, cbind(1, x)),
type = 'p', col = 4, pch = 4)
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
dev.off()
predict.cmp.quantile <- function(q, fit, X){
lam <- exp(X %*% coef(fit)[1:ncol(fit$X)])
nu <- nu(fit)
out <- rep(NA, nrow(X))
for(i in 1:nrow(X)){
out[i] <- qcmp(q, lam[i], nu[i])
}
return(out)
}
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\median.png',
width = 600,height = 600, res = 100)
plot(y, col = 1, pch = 1, main = 'median')
lines(qpois(rep(0.5, n), fit1$fitted.values),
type = 'p', col = 2, pch = 2)
lines(predict.cmp.quantile(0.5, fit2, cbind(1, x)),
type = 'p', col = 3, pch = 3)
lines(predict.cmp.quantile(0.5, fit3, cbind(1, x)),
type = 'p', col = 4, pch = 4)
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
dev.off()
nu(fit2)
fit2
library(COMPoissonReg)
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\median.png',
width = 600,height = 600, res = 100)
plot(y, col = 1, pch = 1, main = 'median')
lines(qpois(rep(0.5, n), fit1$fitted.values),
type = 'p', col = 2, pch = 2)
lines(predict.cmp.quantile(0.5, fit2, cbind(1, x)),
type = 'p', col = 3, pch = 3)
lines(predict.cmp.quantile(0.5, fit3, cbind(1, x)),
type = 'p', col = 4, pch = 4)
legend('topleft', legend = c('obs.', 'Poisson',
'CMP-constant nu',
'CMP-model nu'),
pch = 1:4, col = 1:4)
dev.off()
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\theta.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse, type = 'b', ylim = c(0, 0.35),
col = 1, pch = "1", lwd = 2,
main = 'theta', ylab = 'MSE')
lines(r, mMSE.mse, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\beta.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse.beta, type = 'b', ylim = c(0, 0.3),
col = 1, pch = "1", lwd = 2,
main = 'beta', ylab = 'MSE')
lines(r, mMSE.mse.beta, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.beta, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.beta, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
png('D:\\GitHub\\sub-sampling\\\\COM-Poisson\\cdoe\\gamma.png',
width = 600,height = 600, res = 100)
plot(r, unif.mse.gam, type = 'b', ylim = c(0, 0.07),
col = 1, pch = "1", lwd = 2,
main = 'gamma', ylab = 'MSE')
lines(r, mMSE.mse.gam, type = 'b', col = 2, pch = "2", lwd = 2)
lines(r, mVC.mse.gam, type = 'b', col = 3, pch = "3", lwd = 2)
abline(h = full.mse.gam, lty = 2, lwd = 2, col = 1)
legend('topright', lwd = 2,
lty = c(rep(1, 3), 2), col = c(1:3, 1),
pch = c(as.character(1:3), NA),
legend = c('uniform', 'mMSE', 'mVc', 'full'))
dev.off()
save.image(file = 'comResults.RData')
load("D:/GitHub/sub-sampling/COM-Poisson/cdoe/comResults.RData")
library(COMPoissonReg)
nu(fit2)
plot(nu)
sum(nu<1)
sum(nu>1)
plot(nu(fit3))
nu(fit2)
nu(fit2)[1]
library(COMPoissonReg)
set.seed(123)
#### generate data
n <- 10000
x <- rnorm(n, 0, 1)
beta <- c(0, 1)
lam <- exp(cbind(1, x) %*% beta)
g <- rnorm(n, 1, 1)
gam <- c(1, 1)
nu <- exp(cbind(1, g) %*% gam)
# plot(lam)
# plot(nu)
# abline(h = 1)
# plot(qcmp(rep(0.5, n), lam, nu))
y <- rcmp(n, lam, nu)
ptm <- proc.time()
fit2 <- glm.cmp(formula.lambda = y ~ x)
proc.cmp.nuOff <- proc.time() - ptm
# fit3: fit nu: log(nu) = g %*% gam
ptm <- proc.time()
fit3 <- glm.cmp(formula.lambda = y ~ x, formula.nu = y ~ g)
proc.cmp.nuOn <- proc.time() - ptm
fit2$H
#### common functions
moment_sum <- function(lam, nu, nMax = 500, gradOnly){
# if(lam >= 2 & nu <= 1){
#   alph <- lam^(1/nu)
#   E_y <- alph - (nu - 1)/(2*nu) -
#     (nu^2 - 1)/(alph*24*(nu^2)) -
#     (nu^2 - 1)/(alph^2*24*(nu^3))
#
#   E_logyFac <- alph*(log(lam)/nu - 1) +
#     log(lam)/(2*nu^2) + 1/(2*nu) + log(2*pi)/2 -
#     (1/(24*alph))*(1 + 1/(nu^2) + log(lam)/nu - log(lam)/(nu^3)) -
#     (1/(24*alph^2))*(1/(nu^3) + log(lam)/(nu^2) - log(lam)/nu^4)
#
#   if(gradOnly){
#     Var_y <- NA
#     Var_logyFac <- NA
#     Cov_y_logyFac <- NA
#   }else{
#     Var_y <- alph/nu + (nu^2 - 1)/(alph*24*(nu^3)) +
#       (nu^2 - 1)/(alph^2*12*(nu^4))
#
#
#     Var_logyFac <- alph*(log(lam))^2/(nu^3) + log(lam)/(nu^3) + 1/(2*nu^2) +
#       (1/(alph*24*(nu^5)))*(-2*(nu^2) + 4*nu*log(lam) + (-1 + nu^2)*(log(lam))^2) +
#       (1/((alph^2)*24*(nu^6)))*(-3*nu^2 - 2*nu*(-3 + nu^2)*log(lam) + 2*(-1 + nu^2)*(log(lam))^2)
#
#
#     Cov_y_logyFac <- alph*log(lam)/(nu^2) + 1/(2*nu^2) +
#       (1/(24*alph))*(2/(nu^3) + log(lam)/(nu^2) - log(lam)/(nu^4)) -
#       (1/(24*alph^2))*(1/(nu^2)- 3/(nu^4) - 2*log(lam)/(nu^3) + 2*log(lam)/(nu^5))
#   }
#
# }else{
#   pmf <- dcmp(0:nMax, lam, nu)
#   E_y <- sum((0:nMax)*pmf)
#   E_logyFac <- sum((lgamma(1:(nMax + 1)))*pmf)
#
#   if(gradOnly){
#     Var_y <- NA
#     Var_logyFac <- NA
#     Cov_y_logyFac <- NA
#   }else{
#     Var_y <- sum((0:nMax)^2*pmf) - E_y^2
#     Var_logyFac <- sum((lgamma(1:(nMax + 1))^2)*pmf) - E_logyFac^2
#     Cov_y_logyFac <- sum((0:nMax)*(lgamma(1:(nMax + 1)))*pmf) -E_y*E_logyFac
#   }
# }
pmf <- dcmp(0:nMax, lam, nu)
E_y <- sum((0:nMax)*pmf)
E_logyFac <- sum((lgamma(1:(nMax + 1)))*pmf)
if(gradOnly){
Var_y <- NA
Var_logyFac <- NA
Cov_y_logyFac <- NA
}else{
Var_y <- sum((0:nMax)^2*pmf) - E_y^2
Var_logyFac <- sum((lgamma(1:(nMax + 1))^2)*pmf) - E_logyFac^2
Cov_y_logyFac <- sum((0:nMax)*(lgamma(1:(nMax + 1)))*pmf) -E_y*E_logyFac
}
return(list(E_y = E_y, Var_y = Var_y,
E_logyFac = E_logyFac, Var_logyFac = Var_logyFac,
Cov_y_logyFac = Cov_y_logyFac))
}
gradInfo <- function(x, g, y, beta, gam, gradOnly = F){
X <- cbind(1, x)
G <- cbind(1, g)
lam <- c(exp(X%*% beta))
nu <- c(exp(G %*% gam))
if(gradOnly){
moments <- mapply(moment_sum, lam, nu, gradOnly = T)
info <- NA
}else{
moments <- mapply(moment_sum, lam, nu, gradOnly = F)
}
grad1_each <- (y - unlist(moments['E_y', ]))* X
grad2_each <- nu*(unlist(moments['E_logyFac', ]) - lgamma(y+1))* G
grad_each <- cbind(grad1_each, grad2_each)
grad <- apply(grad_each, 2, sum)
if(!gradOnly){
info1 <- t(X) %*% (unlist(moments['Var_y', ]) * X)
info2 <- t(X) %*% (-nu*unlist(moments['Cov_y_logyFac', ])* G)
info3 <- t(info2)
info4 <- t(G) %*% (nu*(nu*unlist(moments['Var_logyFac', ]) -
unlist(moments['E_logyFac', ]) +
lgamma(y+1)) * G)
info <- rbind(cbind(info1, info2), cbind(info3, info4))
}
return(list(grad_each = grad_each,
grad = grad,
info = info))
}
fit3$H
fit3$beta
fit3$gamma
gradInfo(x, g, y, fit3$beta, fit3$gamma)
fit3$H
gi <- gradInfo(x, g, y, fit3$beta, fit3$gamma)
gi$grad_each
dim(gi$grad_each)
gi$grad
gi$grad_each[1, ]
X <- cbind(1, x)
G <- cbind(1, g)
lamFit <- c(exp(X%*% beta))
nuFit <- c(exp(G %*% gam))
mm <- moment_sum(lamFit, nuFit)
X <- cbind(1, x)
G <- cbind(1, g)
lamFit <- c(exp(X%*% beta))
nuFit <- c(exp(G %*% gam))
lamFit
mm <- mapply(moment_sum, lamFit, nuFit, gradOnly = T)
mm
unlist(mm['E_y', ])
fitted3 <- predict(fit3, newdata = data.frame(x = x, g = g))
com <- data.frame(unlist(mm['E_y', ]), fitted3)
View(com)
?eunif
c(lamFit[1], nuFit[1])
com[1,]
sum((0:500)*dcmp(0:500, lamFit[1], nuFit[1]))
sum((0:1000)*dcmp(0:1000, lamFit[1], nuFit[1]))
?ecmp
?predict.cmp
sum((0:1000)*dcmp(0:1000, lamFit[1], 1)
)
lamFit[1]
nuFit
sum((0:1000)*dcmp(0:1000, lamFit[1], nuFit[1]))
com[1,]
sum((0:10000)*dcmp(0:10000, lamFit[1], nuFit[1]))
sum((0:100)*dcmp(0:100, lamFit[1], nuFit[1]))
sum((0:2)*dcmp(0:2, lamFit[1], nuFit[1]))
dcmp(0:2, lamFit[1], nuFit[1])
dcmp(0:2)
dcmp(0:2, lamFit[1], nuFit[1])
predict(fit3, newdata = data.frame(x = x[1], g = g[1]))
x
x[1]
g[1]
data.frame(x = x[1], g = g[1])
predict(fit3, newdata = data.frame(x = x[1], g = g[1]))
fitted3 <- predict(fit3, newdata = data.frame(x = x[1], g = g[1]))
sum((0:2)*dcmp(0:2, lamFit[1], nuFit[1]))
fitted3[1]
com <- data.frame(unlist(mm['E_y', ]), fitted3, y)
fitted3 <- predict(fit3, newdata = data.frame(x = x, g = g))
mm <- mapply(moment_sum, lamFit, nuFit, gradOnly = T)
com <- data.frame(unlist(mm['E_y', ]), fitted3, y)
com[1,]
plot(com[, 1], com[, 2])
lamFit[1]
nuFit[1]
?rcmp
mean(rcmp(1000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(1000000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(10000, lamFit[1], nuFit[1]))
mean(rcmp(1000000, lamFit[1], nuFit[1]))
set.seed(123)
mean(rcmp(1000000, lam = 0.5709374, nu = 79.10098)
)
set.seed(123)
mean(rcmp(1000000, lam = 0.5709374, nu = 79.10098))
seq(100, 1000, 9)
seq(100, 1000, 100)
seq(1000, 10000, 1000)
procTime <- function(n, seed = 123){
set.seed(123)
x <- rnorm(n, 0, 1)
beta <- c(0, 1)
lam <- exp(cbind(1, x) %*% beta)
g <- rnorm(n, 1, 1)
gam <- c(1, 1)
nu <- exp(cbind(1, g) %*% gam)
y <- rcmp(n, lam, nu)
ptm <- proc.time()
fit <- glm.cmp(formula.lambda = y ~ x, formula.nu = y ~ g)
proc.cmp <- proc.time() - ptm
return(proc.cmp)
}
t <- sapply(procTime, seq(1000, 10000, 1000))
?sapply
t <- sapply(seq(1000, 10000, 1000), procTime)
plot(seq(1000, 10000, 1000), t)
t
plot(seq(1000, 10000, 1000), t[3, ])
procTime <- function(n, seed = 123){
set.seed(123)
x <- rnorm(n, 0, 1)
beta <- c(0, 1)
lam <- exp(cbind(1, x) %*% beta)
g <- rnorm(n, 1, 1)
gam <- c(1, 1)
nu <- exp(cbind(1, g) %*% gam)
y <- rcmp(n, lam, nu)
ptm <- proc.time()
fit <- glm.cmp(formula.lambda = y ~ x, formula.nu = y ~ g)
proc.cmp <- proc.time() - ptm
return(proc.cmp)
}
B <- 1000
tGrid <- seq(1000, 10000, 1000)
TBoot <- matrix(NA, nrow = B, ncol = length(tGrid))
for(i in 1:B){
print(i)
t <- sapply(tGrid, procTime)
TBoot[i, ] <- t[3, ]
}
clc
